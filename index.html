// Draw obstacles
    ctx.fillStyle = 'gray';
    obstacles.forEach(obstacle => {
        ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize - 1, gridSize - 1);
    });

    // Draw power-up
    if (powerUp) {
        ctx.fillStyle = powerUps[powerUp.type].color;
        ctx.fillRect(powerUp.x * gridSize, powerUp.y * gridSize, gridSize - 1, gridSize - 1);
    }
}

function unlockAchievement(achievementKey, data = {}) {
    const achievement = achievements[achievementKey];
    let description = achievement.description;
    
    for (const [key, value] of Object.entries(data)) {
        description = description.replace(`{${key}}`, value);
    }
    
    achievementText.textContent = `${achievement.name}: ${description}`;
    achievementPopup.style.display = 'block';
    setTimeout(() => {
        achievementPopup.style.display = 'none';
    }, 3000);
}

function playSound(sound) {
    if (!isMuted) {
        sound.play();
    }
}

document.addEventListener('keydown', (e) => {
    if (gameState !== 'playing') return;
    
    switch (e.key) {
        case 'ArrowUp': if (dy === 0) { dx = 0; dy = -1; } break;
        case 'ArrowDown': if (dy === 0) { dx = 0; dy = 1; } break;
        case 'ArrowLeft': if (dx === 0) { dx = -1; dy = 0; } break;
        case 'ArrowRight': if (dx === 0) { dx = 1; dy = 0; } break;
    }
});

startButton.addEventListener('click', startGame);
restartButton.addEventListener('click', startGame);

muteButton.addEventListener('click', () => {
    isMuted = !isMuted;
    muteButton.textContent = isMuted ? 'Unmute Sound' : 'Mute Sound';
});

window.addEventListener('resize', () => {
    if (gameState === 'playing') {
        clearInterval(gameLoop);
        startGame();
    } else {
        initializeCanvas();
        drawGame();
    }
});

// Load high score from local storage
highScore = localStorage.getItem('snakeHighScore') || 0;
highScoreElement.textContent = highScore;

// Initial draw
initializeCanvas();
drawGame();